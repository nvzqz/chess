var searchIndex = {};
searchIndex["chess"] = {"doc":"Rust Chess Library This is a chess move generation library for rust.  It is designed to be fast, so that it can be used in a chess engine or UI without performance issues.","items":[[3,"Board","chess","A representation of a chess board.  That's why you're here, right?",null,null],[3,"BitBoard","","A good old-fashioned bitboard You do have access to the actual value, but you are probably better off using the implemented operators to work with this object.",null,null],[12,"0","","",0,null],[3,"CacheTable","","Store a cache of entries, each with an associated hash.",null,null],[3,"ChessMove","","Represent a ChessMove in memory",null,null],[3,"Square","","Represent a square on the chess board",null,null],[3,"MoveGen","","The move generation iterator",null,null],[4,"BoardStatus","","What is the status of this game?",null,null],[13,"Ongoing","","",1,null],[13,"Stalemate","","",1,null],[13,"Checkmate","","",1,null],[4,"CastleRights","","What castle rights does a particular player have?",null,null],[13,"NoRights","","",2,null],[13,"KingSide","","",2,null],[13,"QueenSide","","",2,null],[13,"Both","","",2,null],[4,"Color","","Represent a color.",null,null],[13,"White","","",3,null],[13,"Black","","",3,null],[4,"File","","Describe a file (column) on a chess board",null,null],[13,"A","","",4,null],[13,"B","","",4,null],[13,"C","","",4,null],[13,"D","","",4,null],[13,"E","","",4,null],[13,"F","","",4,null],[13,"G","","",4,null],[13,"H","","",4,null],[4,"Piece","","Represent a chess piece as a very simple enum",null,null],[13,"Pawn","","",5,null],[13,"Knight","","",5,null],[13,"Bishop","","",5,null],[13,"Rook","","",5,null],[13,"Queen","","",5,null],[13,"King","","",5,null],[4,"Rank","","Describe a rank (row) on a chess board",null,null],[13,"First","","",6,null],[13,"Second","","",6,null],[13,"Third","","",6,null],[13,"Fourth","","",6,null],[13,"Fifth","","",6,null],[13,"Sixth","","",6,null],[13,"Seventh","","",6,null],[13,"Eighth","","",6,null],[5,"construct","","This is now a no-op.  It does not need to be called anymore.",null,{"inputs":[],"output":null}],[5,"get_bishop_rays","","Get the rays for a bishop on a particular square.",null,{"inputs":[{"name":"square"}],"output":{"name":"bitboard"}}],[5,"get_rook_rays","","Get the rays for a rook on a particular square.",null,{"inputs":[{"name":"square"}],"output":{"name":"bitboard"}}],[5,"get_rook_moves","","Get the moves for a rook on a particular square, given blockers blocking my movement.",null,{"inputs":[{"name":"square"},{"name":"bitboard"}],"output":{"name":"bitboard"}}],[5,"get_bishop_moves","","Get the moves for a bishop on a particular square, given blockers blocking my movement.",null,{"inputs":[{"name":"square"},{"name":"bitboard"}],"output":{"name":"bitboard"}}],[5,"get_king_moves","","Get the king moves for a particular square.",null,{"inputs":[{"name":"square"}],"output":{"name":"bitboard"}}],[5,"get_knight_moves","","Get the knight moves for a particular square.",null,{"inputs":[{"name":"square"}],"output":{"name":"bitboard"}}],[5,"get_pawn_attacks","","Get the pawn capture move for a particular square, given the pawn's color and the potential victims",null,{"inputs":[{"name":"square"},{"name":"color"},{"name":"bitboard"}],"output":{"name":"bitboard"}}],[5,"get_pawn_quiets","","Get the quiet pawn moves (non-captures) for a particular square, given the pawn's color and the potential blocking pieces.",null,{"inputs":[{"name":"square"},{"name":"color"},{"name":"bitboard"}],"output":{"name":"bitboard"}}],[5,"get_pawn_moves","","Get all the pawn moves for a particular square, given the pawn's color and the potential blocking pieces and victims.",null,{"inputs":[{"name":"square"},{"name":"color"},{"name":"bitboard"}],"output":{"name":"bitboard"}}],[5,"line","","Get a line (extending to infinity, which in chess is 8 squares), given two squares. This line does extend past the squares.",null,{"inputs":[{"name":"square"},{"name":"square"}],"output":{"name":"bitboard"}}],[5,"between","","Get a line between these two squares, not including the squares themselves.",null,{"inputs":[{"name":"square"},{"name":"square"}],"output":{"name":"bitboard"}}],[5,"get_rank","","Get a `BitBoard` that represents all the squares on a particular rank.",null,{"inputs":[{"name":"rank"}],"output":{"name":"bitboard"}}],[5,"get_file","","Get a `BitBoard` that represents all the squares on a particular file.",null,{"inputs":[{"name":"file"}],"output":{"name":"bitboard"}}],[5,"get_adjacent_files","","Get a `BitBoard` that represents the squares on the 1 or 2 files next to this file.",null,{"inputs":[{"name":"file"}],"output":{"name":"bitboard"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"board"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"boardstatus"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"boardstatus"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"boardstatus"}],"output":{"name":"option"}}],[11,"new","","Construct a new `Board` that is completely empty. Note: This does NOT give you the initial position.  Just a blank slate.",7,{"inputs":[],"output":{"name":"board"}}],[11,"from_fen","","Construct a board from a FEN string.",7,{"inputs":[{"name":"string"}],"output":{"name":"option"}}],[11,"status","","Is this game Ongoing, is it Stalemate, or is it Checkmate?",7,{"inputs":[{"name":"self"}],"output":{"name":"boardstatus"}}],[11,"combined","","Grab the \"combined\" `BitBoard`.  This is a `BitBoard` with every piece.",7,{"inputs":[{"name":"self"}],"output":{"name":"bitboard"}}],[11,"color_combined","","Grab the \"color combined\" `BitBoard`.  This is a `BitBoard` with every piece of a particular color.",7,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"bitboard"}}],[11,"king_square","","Give me the `Square` the `color` king is on.",7,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"square"}}],[11,"pieces","","Grab the \"pieces\" `BitBoard`.  This is a `BitBoard` with every piece of a particular type.",7,{"inputs":[{"name":"self"},{"name":"piece"}],"output":{"name":"bitboard"}}],[11,"castle_rights","","Grab the `CastleRights` for a particular side.",7,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"castlerights"}}],[11,"add_castle_rights","","Add castle rights for a particular side.",7,{"inputs":[{"name":"self"},{"name":"color"},{"name":"castlerights"}],"output":null}],[11,"remove_castle_rights","","Remove castle rights for a particular side.",7,{"inputs":[{"name":"self"},{"name":"color"},{"name":"castlerights"}],"output":null}],[11,"side_to_move","","Who's turn is it?",7,{"inputs":[{"name":"self"}],"output":{"name":"color"}}],[11,"my_castle_rights","","Grab my `CastleRights`.",7,{"inputs":[{"name":"self"}],"output":{"name":"castlerights"}}],[11,"add_my_castle_rights","","Add to my `CastleRights`.",7,{"inputs":[{"name":"self"},{"name":"castlerights"}],"output":null}],[11,"remove_my_castle_rights","","Remove some of my `CastleRights`.",7,{"inputs":[{"name":"self"},{"name":"castlerights"}],"output":null}],[11,"their_castle_rights","","My opponents `CastleRights`.",7,{"inputs":[{"name":"self"}],"output":{"name":"castlerights"}}],[11,"add_their_castle_rights","","Add to my opponents `CastleRights`.",7,{"inputs":[{"name":"self"},{"name":"castlerights"}],"output":null}],[11,"remove_their_castle_rights","","Remove some of my opponents `CastleRights`.",7,{"inputs":[{"name":"self"},{"name":"castlerights"}],"output":null}],[11,"set_piece","","For a chess UI: set a piece on a particular square.",7,{"inputs":[{"name":"self"},{"name":"piece"},{"name":"color"},{"name":"square"}],"output":{"name":"option"}}],[11,"clear_square","","For a chess UI: clear a particular square.",7,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"option"}}],[11,"null_move","","Switch the color of the player without actually making a move.",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_sane","","Does this board \"make sense\"? Do all the pieces make sense, do the bitboards combine correctly, etc? This is for sanity checking.",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get_hash","","Get a hash of the board.",7,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"get_pawn_hash","","Get a pawn hash of the board (a hash that only changes on color change and pawn moves).",7,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"piece_on","","What piece is on a particular `Square`?  Is there even one?",7,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"option"}}],[11,"enumerate_moves","","Give me all the legal moves for this board.",7,null],[11,"en_passant","","Give me the en_passant square, if it exists.",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"legal","","Is a particular move legal?",7,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"bool"}}],[11,"legal_quick","","This function checks the legality only for moves generated by `MoveGen`.",7,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"bool"}}],[11,"make_move","","Make a chess move.",7,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"board"}}],[11,"perft","","Run a perft-test.",7,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"perft_brute_force","","Run a perft-test using brute force move generation.",7,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"perft_cache","","Run a perft test with a cache table.",7,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"usize"}],"output":{"name":"u64"}}],[11,"pinned","","Give me the `BitBoard` of my pinned pieces.",7,{"inputs":[{"name":"self"}],"output":{"name":"bitboard"}}],[11,"checkers","","Give me the `Bitboard` of the pieces putting me in check.",7,{"inputs":[{"name":"self"}],"output":{"name":"bitboard"}}],[11,"legal_king_move","","Is a particular king move legal?",7,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"bool"}}],[11,"legal_ep_move","","Is a particular en-passant capture legal?",7,{"inputs":[{"name":"self"},{"name":"square"},{"name":"square"}],"output":{"name":"bool"}}],[11,"perft_test","","Run every type of perft test, and panic! if the leaf-node count of any version is not equal to `result`.",7,{"inputs":[{"name":"string"},{"name":"u64"},{"name":"u64"}],"output":null}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bitboard"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bitand","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"bitboard"}}],[11,"bitor","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"bitboard"}}],[11,"bitxor","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"bitboard"}}],[11,"bitand_assign","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":null}],[11,"bitor_assign","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":null}],[11,"bitxor_assign","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":null}],[11,"mul","","",0,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":{"name":"bitboard"}}],[11,"not","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bitboard"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Construct a new bitboard from a u64",0,{"inputs":[{"name":"u64"}],"output":{"name":"bitboard"}}],[11,"set","","Construct a new `BitBoard` with a particular `Square` set",0,{"inputs":[{"name":"rank"},{"name":"file"}],"output":{"name":"bitboard"}}],[11,"from_square","","Construct a new `BitBoard` with a particular `Square` set",0,{"inputs":[{"name":"square"}],"output":{"name":"bitboard"}}],[11,"from_maybe_square","","Convert an `Option<Square>` to an `Option<BitBoard>`",0,{"inputs":[{"name":"option"}],"output":{"name":"option"}}],[11,"to_square","","Convert a `BitBoard` to a `Square`.  This grabs the least-significant `Square`",0,{"inputs":[{"name":"self"}],"output":{"name":"square"}}],[11,"popcnt","","Count the number of `Squares` set in this `BitBoard`",0,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"reverse_colors","","Reverse this `BitBoard`.  Look at it from the opponents perspective.",0,{"inputs":[{"name":"self"}],"output":{"name":"bitboard"}}],[11,"to_size","","Convert this `BitBoard` to a `usize` (for table lookups)",0,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"usize"}}],[11,"next","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create a new `CacheTable` with each associated entry initialized with a hash of '0' Note: You must pass in a size where only 1 bit is set. (AKA: 2, 4, 8, 16, 1024, 65536, etc.) Panics when size is invalid.",8,{"inputs":[{"name":"usize"},{"name":"t"}],"output":{"name":"cachetable"}}],[11,"get","","Get a particular entry with the hash specified",8,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"option"}}],[11,"add","","Add (or overwrite) an entry with the associated hash",8,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"t"}],"output":null}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"castlerights"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"castlerights"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"self"},{"name":"castlerights"}],"output":{"name":"option"}}],[11,"has_kingside","","Can I castle kingside?",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"has_queenside","","Can I castle queenside?",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kingside_squares","","What squares need to be empty to castle kingside?",2,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"bitboard"}}],[11,"queenside_squares","","What squares need to be empty to castle queenside?",2,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"bitboard"}}],[11,"remove","","Remove castle rights, and return a new `CastleRights`.",2,{"inputs":[{"name":"self"},{"name":"castlerights"}],"output":{"name":"castlerights"}}],[11,"add","","Add some castle rights, and return a new `CastleRights`.",2,{"inputs":[{"name":"self"},{"name":"castlerights"}],"output":{"name":"castlerights"}}],[11,"to_index","","Convert `CastleRights` to `usize` for table lookups",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"from_index","","Convert `usize` to `CastleRights`.  Panic if invalid number.",2,{"inputs":[{"name":"usize"}],"output":{"name":"castlerights"}}],[11,"unmoved_rooks","","Which rooks can we \"guarantee\" we haven't moved yet?",2,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"bitboard"}}],[11,"rook_square_to_castle_rights","","Given a square of a rook, which side is it on? Note: It is invalid to pass in a non-rook square.  The code may panic.",2,{"inputs":[{"name":"square"}],"output":{"name":"castlerights"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"chessmove"}}],[11,"partial_cmp","","",9,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"option"}}],[11,"lt","","",9,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"bool"}}],[11,"le","","",9,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"bool"}}],[11,"gt","","",9,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"bool"}}],[11,"ge","","",9,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"bool"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"bool"}}],[11,"new","","Create a new chess move, given a source `Square`, a destination `Square`, and an optional promotion `Piece`",9,{"inputs":[{"name":"square"},{"name":"square"},{"name":"option"}],"output":{"name":"chessmove"}}],[11,"get_source","","Get the source square (square the piece is currently on).",9,{"inputs":[{"name":"self"}],"output":{"name":"square"}}],[11,"get_dest","","Get the destination square (square the piece is going to).",9,{"inputs":[{"name":"self"}],"output":{"name":"square"}}],[11,"get_promotion","","Get the promotion piece (maybe).",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cmp","","",9,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"option"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"color"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"to_index","","Convert the `Color` to a `usize` for table lookups.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"to_my_backrank","","Covert the `Color` to a rank, which reperesnts the starting position for that colors pieces.",3,{"inputs":[{"name":"self"}],"output":{"name":"rank"}}],[11,"to_their_backrank","","Convert a `Color` to my opponents backrank, which represents the starting position for the opponents pieces.",3,{"inputs":[{"name":"self"}],"output":{"name":"rank"}}],[11,"to_second_rank","","Convert a `Color` to my second rank, which represents the starting position for my pawns.",3,{"inputs":[{"name":"self"}],"output":{"name":"rank"}}],[11,"to_seventh_rank","","Convert a `Color` to my seventh rank, which represents the rank before pawn promotion.",3,{"inputs":[{"name":"self"}],"output":{"name":"rank"}}],[11,"not","","Get the other color.",3,{"inputs":[{"name":"self"}],"output":{"name":"color"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"file"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"file"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",4,{"inputs":[{"name":"self"},{"name":"file"}],"output":{"name":"option"}}],[11,"from_index","","Convert a `usize` into a `File` (the inverse of to_index).  If i > 7, wrap around.",4,{"inputs":[{"name":"usize"}],"output":{"name":"file"}}],[11,"left","","Go one file to the left.  If impossible, wrap around.",4,{"inputs":[{"name":"self"}],"output":{"name":"file"}}],[11,"right","","Go one file to the right.  If impossible, wrap around.",4,{"inputs":[{"name":"self"}],"output":{"name":"file"}}],[11,"to_index","","Convert this `File` into a `usize` from 0 to 7 inclusive.",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"piece"}],"output":{"name":"bool"}}],[11,"cmp","","",5,{"inputs":[{"name":"self"},{"name":"piece"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",5,{"inputs":[{"name":"self"},{"name":"piece"}],"output":{"name":"option"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"piece"}}],[11,"to_index","","Convert the `Piece` to a `usize` for table lookups.",5,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"rank"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"rank"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",6,{"inputs":[{"name":"self"},{"name":"rank"}],"output":{"name":"option"}}],[11,"from_index","","Convert a `usize` into a `Rank` (the inverse of to_index).  If the number is > 7, wrap around.",6,{"inputs":[{"name":"usize"}],"output":{"name":"rank"}}],[11,"down","","Go one rank down.  If impossible, wrap around.",6,{"inputs":[{"name":"self"}],"output":{"name":"rank"}}],[11,"up","","Go one file up.  If impossible, wrap around.",6,{"inputs":[{"name":"self"}],"output":{"name":"rank"}}],[11,"to_index","","Convert this `Rank` into a `usize` between 0 and 7 (inclusive).",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"bool"}}],[11,"cmp","","",10,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",10,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"option"}}],[11,"lt","","",10,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"bool"}}],[11,"le","","",10,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"bool"}}],[11,"gt","","",10,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"bool"}}],[11,"ge","","",10,{"inputs":[{"name":"self"},{"name":"square"}],"output":{"name":"bool"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"square"}}],[11,"new","","Create a new square, given an index. Note: It is invalid, but allowed, to pass in a number >= 64.  Doing so will crash stuff.",10,{"inputs":[{"name":"u8"}],"output":{"name":"square"}}],[11,"make_square","","Make a square given a rank and a file",10,{"inputs":[{"name":"rank"},{"name":"file"}],"output":{"name":"square"}}],[11,"get_rank","","Return the rank given this square.",10,{"inputs":[{"name":"self"}],"output":{"name":"rank"}}],[11,"get_file","","Return the file given this square.",10,{"inputs":[{"name":"self"}],"output":{"name":"file"}}],[11,"up","","If there is a square above me, return that.  Otherwise, None.",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"down","","If there is a square below me, return that.  Otherwise, None.",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"left","","If there is a square to the left of me, return that.  Otherwise, None.",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"right","","If there is a square to the right of me, return that.  Otherwise, None.",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"forward","","If there is a square \"forward\", given my `Color`, go in that direction.  Otherwise, None.",10,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"option"}}],[11,"backward","","If there is a square \"backward\" given my `Color`, go in that direction.  Otherwise, None.",10,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"option"}}],[11,"uup","","If there is a square above me, return that.  If not, wrap around to the other side.",10,{"inputs":[{"name":"self"}],"output":{"name":"square"}}],[11,"udown","","If there is a square below me, return that.  If not, wrap around to the other side.",10,{"inputs":[{"name":"self"}],"output":{"name":"square"}}],[11,"uleft","","If there is a square to the left of me, return that. If not, wrap around to the other side.",10,{"inputs":[{"name":"self"}],"output":{"name":"square"}}],[11,"uright","","If there is a square to the right of me, return that.  If not, wrap around to the other side.",10,{"inputs":[{"name":"self"}],"output":{"name":"square"}}],[11,"uforward","","If there is a square \"forward\", given my color, return that.  If not, wrap around to the other side.",10,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"square"}}],[11,"ubackward","","If there is a square \"backward\", given my color, return that.  If not, wrap around to the other side.",10,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"square"}}],[11,"to_int","","Convert this square to an integer.",10,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"to_index","","Convert this `Square` to a `usize` for table lookup purposes",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"from_string","","Convert a UCI `String` to a square.  If invalid, return `None`",10,{"inputs":[{"name":"string"}],"output":{"name":"option"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `MoveGen` structure, specifying whether or not you want legal or pseudo_legal moves",11,{"inputs":[{"name":"board"},{"name":"bool"}],"output":{"name":"movegen"}}],[11,"remove_mask","","Never, ever, iterate any moves that land on the following squares",11,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":null}],[11,"remove_move","","Never, ever, iterate this move",11,{"inputs":[{"name":"self"},{"name":"chessmove"}],"output":{"name":"bool"}}],[11,"set_iterator_mask","","For now, Only iterate moves that land on the following squares Note: Once iteration is completed, you can pass in a mask of ! `EMPTY`       to get the remaining moves, or another mask",11,{"inputs":[{"name":"self"},{"name":"bitboard"}],"output":null}],[11,"movegen_perft_test","","Fastest perft test with this structure",11,{"inputs":[{"name":"board"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"len","","Give the exact length of this iterator",11,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size_hint","","Give a size_hint to some functions that need it",11,null],[11,"next","","Find the next chess move.",11,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[17,"EMPTY","","An empty bitboard",null,null],[17,"NUM_CASTLE_RIGHTS","","How many different types of `CastleRights` are there?",null,null],[17,"ALL_CASTLE_RIGHTS","","Enumerate all castle rights.",null,null],[17,"NUM_COLORS","","How many colors are there?",null,null],[17,"ALL_COLORS","","List all colors",null,null],[17,"NUM_FILES","","How many files are there?",null,null],[17,"ALL_FILES","","Enumerate all files",null,null],[17,"EDGES","","What are all the edge squares on the `BitBoard`?",null,null],[17,"NUM_PIECES","","How many piece types are there?",null,null],[17,"ALL_PIECES","","An array representing each piece type, in order of ascending value.",null,null],[17,"NUM_PROMOTION_PIECES","","How many ways can I promote?",null,null],[17,"PROMOTION_PIECES","","What pieces can I promote to?",null,null],[17,"NUM_RANKS","","How many ranks are there?",null,null],[17,"ALL_RANKS","","Enumerate all ranks",null,null],[17,"NUM_SQUARES","","How many squares are there?",null,null],[17,"ALL_SQUARES","","A list of every square on the chessboard.",null,null]],"paths":[[3,"BitBoard"],[4,"BoardStatus"],[4,"CastleRights"],[4,"Color"],[4,"File"],[4,"Piece"],[4,"Rank"],[3,"Board"],[3,"CacheTable"],[3,"ChessMove"],[3,"Square"],[3,"MoveGen"]]};
initSearch(searchIndex);
